# Architecture Decision Record: TaskTracker Project

## ADR 001: Architecture Decision for TaskTracker Project

**TaskTracker** is a .NET 9 solution for managing tasks, designed for **scalability**, **maintainability**, and **testability**. The project uses **C# 13** and modern .NET features.

### Requirements
- RESTful API for task management  
- Separation of concerns  
- Easy unit and integration testing  
- Extensibility for future features  

---

## Decision

### 1. Layered Architecture
- **Presentation Layer**: ASP.NET Core API controllers (e.g., `TaskController`).
- **Application Layer**: CQRS handlers, validators, and business logic.
- **Domain Layer**: Core entities and value objects (e.g., `TaskItem`, `Status`, `Priority`).
- **Infrastructure Layer**: Data access, repositories, and external integrations.

### 2. CQRS Pattern with MediatR
- Commands and queries are handled by dedicated handlers (e.g., `CreateTaskCommandHandler`, `GetAllTasksQueryHandler`).
- MediatR is used for decoupling request handling from controllers.

### 3. Validation
- **FluentValidation** is used for request validation (e.g., `CreateTaskCommandValidator`, `UpdateTaskCommandValidator`).

### 4. Error Handling
- The `ErrorOr` type is used for consistent error and success responses.
- API controllers use a base class (`ApiController`) to standardize error responses.

### 5. Testing
- **xUnit** and **Moq** are used for unit testing.
- Validators and handlers have dedicated test classes.

### 6. Repository & Unit of Work Pattern
- Data access is abstracted via repository interfaces (e.g., `ITaskTrackerRepository`).
- Unit of Work is used to group related operations into a single transaction, ensuring consistency and simplifying commit/rollback logic.
- Supports mocking and swapping implementations for testing.

### 7. .NET 9 & C# 13 Features
- Latest language features are used for improved performance and readability.
- `async/await` is used for all I/O operations.

---

## Consequences

### ✅ Pros
- High **maintainability**, **testability**, and **scalability**.
- Easy to add new features and swap infrastructure.
- Transactional consistency with **Unit of Work**.

### ⚠️ Cons
- More boilerplate code due to **CQRS**, layered separation, and Unit of Work.
- Requires familiarity with **MediatR**, **FluentValidation**, and **Unit of Work** patterns.

---

## Alternatives Considered
- ❌ **Monolithic Controllers**: Rejected for poor separation of concerns.
- ❌ **Direct EF Usage in Controllers**: Rejected for testability and maintainability reasons.
- ❌ **No Unit of Work**: Rejected due to risk of inconsistent data changes across multiple repositories.

---

## Related Decisions
- Use of **MediatR** for CQRS.
- Use of **FluentValidation** for input validation.
- Use of **ErrorOr** for error handling.
- Use of **Unit of Work** for transactional consistency.

---

## References
- [CQRS Pattern](https://learn.microsoft.com/en-us/azure/architecture/patterns/cqrs)
- [MediatR](https://github.com/jbogard/MediatR)
- [FluentValidation](https://docs.fluentvalidation.net/)
- [.NET 9 Documentation](https://learn.microsoft.com/en-us/dotnet/core/dotnet-nine)
- [Unit of Work Pattern](https://martinfowler.com/eaaCatalog/unitOfWork.html)
